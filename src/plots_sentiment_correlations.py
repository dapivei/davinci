# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zxLqKBn4Baf1x9-ClcgqDZJTM_5KfNOs
"""

import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.ticker as mtick

!gdown https://drive.google.com/uc?id=1kFlGlyRvA3MmkDzrb6fTDiBs-hgnwy-9
!gdown https://drive.google.com/uc?id=1zZTD_GssjNGxm43YU3XVUdOQtHOrt0M2
!gdown https://docs.google.com/uc?id=1422845nd5dRobCIkUgNfJ9gN1sLzye0c
!gdown https://docs.google.com/uc?id=1Q6vNar9GbNK6niUexqPYRH59NkQ2nH3q
!gdown https://docs.google.com/uc?id=1M5rw8KXVCQ9ohQRtHl1neTKP-SuPrcmf
!gdown https://docs.google.com/uc?id=1VaheANA_IYWDsM22mfMbRfhi30I9yYfR
!gdown https://docs.google.com/uc?id=17aQkcCnoBfG2n-oXXRmTOdmcNlNy7hDe
!gdown https://docs.google.com/uc?id=1Icai-DiCr59rFkgNdpCQ-p3laa64WPg7

sentiment=pd.read_csv('sentiment.csv')

sentiment.columns

sorted_df = sentiment.sort_values(by='P+', ascending=True)  # ascending=True for ascending order, False for descending order
x_=sorted_df.tail(50)

' Perdón, no entiendo su pregunta.\n',
 ' No puedo hablar, no te puedo contestar, porque en uno de esos estados que mencionaste hay elecciones y no quiero hablar de eso.\nEl lunes hablamos, si te parece, tú abres la sesión, para que no nos metamos en esos asuntos.\n',
 ' (Inaudible) y no me da la palabra.\n',
 ' De Puerto Vallarta (inaudible)\xa0\n',
 ' Creo que está mal eso.\n',
 '\xa0Pero, entonces, hay un fallo entre el OPLE y el gobierno estatal, porque ayer no tenía…\n',
 ' Me hizo un motín emocional ayer, porque dice que ya lleva meses y que no pregunta.\n',
 ' ¿Desaparece la ASA?\n',
 ' Es que está (inaudible) porque ya en el debido proceso están judicializados, podemos afectar el proceso si damos los nombres.\n',
 ' Falta el mobiliario, y nos falta ya concluir el museo, ¿no?, básicamente.\n',
 ' Falta Cabeza de Vaca.\n',
 '\xa0¿Rechaza cualquier distanciamiento, que se rompan las mesas de…?\n',
 ' Un mal aire.\n',

' Gracias, presidente. Bueno…\n',
 ' Muy buenos días, presidente. Gracias por la oportunidad.\n',
 ' Pues mucho éxito y muchas gracias a todos y a todas.\n¿Sinaloa ya estará? Hola, buenos días.\nPAMELA LÓPEZ RUIZ, ',
 ' Muchas gracias.\nProcederemos ahora a la entrega de reconocimientos a las organizaciones fundadoras de la Unión Mexicana de Asociaciones de Ingenieros.\nEn primer lugar, en nombre de la Sociedad Geológica Mexicana A.C., recibe el doctor Ricardo Barragán Manzo. Muchas felicidades.\nEn nombre de la Asociación Mexicana de Ingenieros Mecánicos y Electricistas, recibe el premio la ingeniera Lilia Coronel Zamora. Muchas felicidades.\nEn nombre del Colegio de Ingenieros Militares teniente de ingenieros ‘Juan de la Barrera’, recibe el premio el teniente coronel industrial militar José Luis Galarza Portugués. Muchas felicidades.\nEn nombre del Colegio de Ingenieros Mecánicos y Electricistas, recibe el premio el ingeniero Ricardo Jesús Morales Salazar. Felicidades.\nY, por último, en nombre del Colegio de Ingenieros Civiles de México, recibe el premio el ingeniero Jorge Serra Moreno. Muchas felicidades.\nMuy buenos días. Muchas gracias a todas y a todos por habernos acompañado en estas dos ceremonias o una sola ceremonia de dos entregas.\xa0\nMuchas gracias, señor presidente; gracias, secretaria Frausto; gracias a los ingenieros y muchas felicidades a los nueve premiados y a los cinco más premiados de los ingenieros.\nPor ahora damos por terminada esta ceremonia y continúa la conferencia de prensa normalmente.\n',
 ' Impresionante. Veo a algunos periodistas que conozco en mis conferencias de prensa cuando venía, siempre buena onda aquí.\nEsta plegaria que usted me dijo que escuchaba cuando nos conocimos en La Habana, ahora con su viaje, en aquella reunión para mí histórica que tuvimos en privado, arte, Silvio, el presidente y yo, aquel día él me dijo que esta canción le gustaba mucho.\nEsta es una canción a la Virgen de la Caridad del Cobre, nuestra virgencita, patrona de Cuba. Es, por supuesto, como todas nuestras vírgenes, una rotación de la Virgen María, así que también voy a extender esta plegaria hoy a la Virgen de la Guadalupe, patrona de América.\nEsto es de José María Vitier, gran maestro, gran amigo, su música y la letra del artista de las artes visuales, su esposa Silvia Rodríguez Rivero, que tenemos el gusto siempre de participar en la misa cubana, esta es la obra que cierra oficialmente la misa cubana que hemos tenido la suerte de presentar en muchísimos países. Así que, Virgen de la Caridad del Cobre.\n(',
 '\xa0Buenos días. Ánimo, ánimo.\nBueno, pues vamos a informar. Hay una muy buena noticia, pero la vamos a dejar para más tarde.\nEmpezamos con quién es quién en los precios y luego vemos los videos y de manera especial vamos a tratar lo del salvamento arqueológico en toda la ruta del Tren Maya con el antropólogo Diego Prieto, y luego continuamos.\nFelicitaciones a Guillermo del Toro, director de cine mexicano, por el premio Óscar por la película\xa0Pinocho.\xa0Nuestras felicitaciones a este mexicano excepcional, cineasta Guillermo del Toro, es un orgullo para México.\nDe lo que voy a hablar más adelante, que creo que es también una muy buena noticia, mucho muy buena, es que ganó nuestra selección de béisbol, le ganó a Estados Unidos, de eso vamos a hablar más adelante, es todo un acontecimiento, 11-5, bien\xa0arreglados.\nBueno, vamos.\n\n\n\n\nRICARDO SHEFFIELD PADILLA, ',
 ' Muchas felicidades, maestra.\nEntonces, un extraordinario recuerdo para muchos mexicanos.\nTerminamos con este reconocimiento, este acto y vamos a abrir para preguntas y respuestas. A ver, vamos, los tres primeros y luego nos vamos para allá.\n'

list(x_['speech'])

def convert_volume(volume_str):
    if isinstance(volume_str, float):
        return volume_str
    multiplier = 1
    if 'M' in volume_str:
        multiplier = 1000000
    elif 'B' in volume_str:
        multiplier = 1000000000
    return float(volume_str.replace('M', '').replace('B', '')) * multiplier

import pandas as pd
import plotly.express as px
ipc = pd.read_csv('sp_bmv_ipc.csv')
columns = ['Price', 'Open', 'High', 'Low']
for col in columns:
    ipc[col] = ipc[col].str.replace(',', '').astype(float)
ipc['Vol.'] = ipc['Vol.'].apply(convert_volume)
ipc['Date'] = pd.to_datetime(ipc['Date'], format='%m/%d/%Y')

def time_series(df, indicator, date='Date', freq='D'):
    """
    Plots a time series of Price against Date using Plotly.

    Parameters:
    - df: DataFrame containing the data.
    - indicator: Name of the column representing the indicator.
    - date: Name of the column representing the date (default is 'Date').
    - freq: Frequency for grouping the data ('D' for daily, 'M' for monthly, 'Y' for yearly).
    """
    # Group data based on frequency
    if freq == 'M':
        df_grouped = df.groupby(pd.Grouper(key=date, freq='M')).mean().reset_index()
    elif freq == 'Y':
        df_grouped = df.groupby(pd.Grouper(key=date, freq='Y')).mean().reset_index()
    else:
        df_grouped = df

    # Plot
    fig = px.line(df_grouped, x=date, y=indicator, title=f'Time Series of {indicator} by {freq}')
    fig.update_xaxes(title='Date', tickangle=45)
    fig.update_yaxes(title=indicator, tickformat=",.0f")
    fig.show()

df = df.drop('Change %', axis=1)
columns = ['Price']
for col in columns:
   # Plot daily time series
  time_series(df, col, freq='D')

  # Plot monthly time series
  time_series(df, col,  freq='M')

# Plot yearly time series
  time_series(df, col, freq='Y')


### SECOND SET OF PLOTS

sentiment=pd.read_csv('sentiment.csv')
import plotly.express as px
import pandas as pd

# Assuming your data is stored in a DataFrame named df
df = sentiment.drop('speech', axis=1)
# Convert 'timestamp' column to datetime
df['timestamp'] = pd.to_datetime(df['timestamp'])

# Rename the 'timestamp' column to avoid conflict
df.rename(columns={'timestamp': 'date'}, inplace=True)
# Aggregate data by month
monthly_data = df.drop(columns=['date']).groupby(df_new['date'].dt.to_period('M')).mean().reset_index()

monthly_data['date'] = monthly_data['date'].astype(str)



# Aggregate data by year
yearly_data = df.drop(columns=['date']).groupby(df['date'].dt.year).mean().reset_index()

# Plot daily data
#fig1 = px.line(daily_data, x='date', y=['N-', 'N', 'NEU', 'NONE', 'P', 'P+'],
               #title='Daily Aggregated Sentiment Scores')
#fig1.show()

# Plot monthly data
fig2 = px.line(monthly_data, x='date', y=['N-', 'N', 'NEU', 'NONE', 'P', 'P+'],
               title='Monthly Aggregated Sentiment Scores')
fig2.show()

# Plot yearly data
fig3 = px.line(yearly_data, x='date', y=['N-', 'N', 'NEU', 'NONE', 'P', 'P+'],
               title='Yearly Aggregated Sentiment Scores')
fig3.show()

import pandas as pd
import plotly.graph_objects as go

# Load IPC data
ipc = pd.read_csv('sp_bmv_ipc.csv')
columns_ipc = ['Price', 'Open', 'High', 'Low']
for col in columns_ipc:
    ipc[col] = ipc[col].str.replace(',', '').astype(float)
ipc['Vol.'] = ipc['Vol.'].apply(convert_volume)
ipc['Date'] = pd.to_datetime(ipc['Date'], format='%m/%d/%Y')

# Load sentiment data
sentiment = pd.read_csv('sentiment.csv')
sentiment['date'] = pd.to_datetime(sentiment['timestamp'])
sentiment.drop(columns=['timestamp', 'speech'], inplace=True)
sentiment_grouped = sentiment.groupby(pd.Grouper(key='date', freq='M')).mean().reset_index()

# Create IPC and sentiment subplots
fig = go.Figure()

# Plot IPC data
for col in columns_ipc:
    fig.add_trace(go.Scatter(x=ipc['Date'], y=ipc[col], mode='lines', name=f'IPC {col}'))

# Add a second y-axis for sentiment data
fig.update_layout(yaxis2=dict(anchor="x", overlaying="y", side="right", title="Sentiment"))

# Plot sentiment data
fig.add_trace(go.Scatter(x=sentiment_grouped['date'], y=sentiment_grouped['N-'], mode='lines', name='N-',
                         yaxis="y2"))
fig.add_trace(go.Scatter(x=sentiment_grouped['date'], y=sentiment_grouped['N'], mode='lines', name='N-',
                         yaxis="y2"))
fig.add_trace(go.Scatter(x=sentiment_grouped['date'], y=sentiment_grouped['NEU'], mode='lines', name='NEU',
                         yaxis="y2"))
fig.add_trace(go.Scatter(x=sentiment_grouped['date'], y=sentiment_grouped['NONE'], mode='lines', name='NONE',
                         yaxis="y2"))
fig.add_trace(go.Scatter(x=sentiment_grouped['date'], y=sentiment_grouped['P'], mode='lines', name='P',
                         yaxis="y2"))
fig.add_trace(go.Scatter(x=sentiment_grouped['date'], y=sentiment_grouped['P+'], mode='lines', name='P+',
                         yaxis="y2"))

# Update layout
fig.update_layout(
    title='IPC and Sentiment Time Series',
    xaxis_title='Date',
    yaxis_title='IPC',
    yaxis2_title='Sentiment',
    xaxis=dict(tickangle=45),
    yaxis=dict(tickformat=","),
    yaxis2=dict(tickformat=","),
    legend_title='Indicator'
)

fig.show()

import pandas as pd
import plotly.graph_objects as go

# Load IPC data
ipc = pd.read_csv('sp_bmv_ipc.csv')
columns_ipc = ['Price', 'Open', 'High', 'Low']
for col in columns_ipc:
    ipc[col] = ipc[col].str.replace(',', '').astype(float)
ipc['Vol.'] = ipc['Vol.'].apply(convert_volume)
ipc['Date'] = pd.to_datetime(ipc['Date'], format='%m/%d/%Y')

# Load sentiment data
sentiment = pd.read_csv('sentiment.csv')
sentiment['date'] = pd.to_datetime(sentiment['timestamp'])
sentiment.drop(columns=['timestamp', 'speech'], inplace=True)
sentiment_grouped = sentiment.groupby(pd.Grouper(key='date', freq='M')).mean().reset_index()

# Create IPC and sentiment subplots
fig = go.Figure()

# Plot IPC data
for col in columns_ipc:
    fig.add_trace(go.Scatter(x=ipc['Date'], y=ipc[col], mode='lines', name=f'IPC {col}', visible='legendonly'))

# Add a second y-axis for sentiment data
fig.update_layout(yaxis2=dict(anchor="x", overlaying="y", side="right", title="Sentiment"))

# Plot sentiment data
fig.add_trace(go.Scatter(x=sentiment_grouped['date'], y=sentiment_grouped['N-'], mode='lines', name='N-',
                         yaxis="y2"))
fig.add_trace(go.Scatter(x=sentiment_grouped['date'], y=sentiment_grouped['N'], mode='lines', name='N-',
                         yaxis="y2"))
fig.add_trace(go.Scatter(x=sentiment_grouped['date'], y=sentiment_grouped['NEU'], mode='lines', name='NEU',
                         yaxis="y2"))
fig.add_trace(go.Scatter(x=sentiment_grouped['date'], y=sentiment_grouped['NONE'], mode='lines', name='NONE',
                         yaxis="y2"))
fig.add_trace(go.Scatter(x=sentiment_grouped['date'], y=sentiment_grouped['P'], mode='lines', name='P',
                         yaxis="y2"))
fig.add_trace(go.Scatter(x=sentiment_grouped['date'], y=sentiment_grouped['P+'], mode='lines', name='P+',
                         yaxis="y2"))

# Update layout
fig.update_layout(
    title='IPC and Sentiment Time Series',
    xaxis_title='Date',
    yaxis_title='IPC',
    yaxis2_title='Sentiment',
    xaxis=dict(tickangle=45),
    yaxis=dict(tickformat=","),
    yaxis2=dict(tickformat=","),
    legend_title='Indicator'
)

fig.show()

import pandas as pd
import plotly.graph_objects as go
from plotly.subplots import make_subplots

# Load IPC data
ipc = pd.read_csv('sp_bmv_ipc.csv')
columns_ipc = ['Price', 'Open', 'High', 'Low']
for col in columns_ipc:
    ipc[col] = ipc[col].str.replace(',', '').astype(float)
ipc['Vol.'] = ipc['Vol.'].apply(convert_volume)
ipc['Date'] = pd.to_datetime(ipc['Date'], format='%m/%d/%Y')

# Load sentiment data
sentiment = pd.read_csv('sentiment.csv')
sentiment['date'] = pd.to_datetime(sentiment['timestamp'])
sentiment.drop(columns=['timestamp', 'speech'], inplace=True)
sentiment_grouped = sentiment.groupby(pd.Grouper(key='date', freq='M')).mean().reset_index()

# Create subplots with shared x-axis
fig = make_subplots(rows=2, cols=1, shared_xaxes=True, subplot_titles=("IPC Time Series", "Sentiment Time Series"))

# Plot IPC data
for col in columns_ipc:
    fig.add_trace(go.Scatter(x=ipc['Date'], y=ipc[col], mode='lines', name=f'IPC {col}'), row=1, col=1)

# Plot sentiment data
for col in sentiment_grouped.columns[1:]:  # Exclude 'date' column
    fig.add_trace(go.Scatter(x=sentiment_grouped['date'], y=sentiment_grouped[col], mode='lines', name=col), row=2, col=1)

# Update layout
fig.update_layout(
    title_text="IPC and Sentiment Time Series",
    xaxis=dict(title='Date', tickangle=45),
    yaxis=dict(title='IPC', tickformat=","),
    yaxis2=dict(title='Sentiment', tickformat=","),
    legend=dict(
        x=0,
        y=1,
        traceorder="normal",
        font=dict(
            family="sans-serif",
            size=12,
            color="black"
        ),
        bgcolor="LightSteelBlue",
        bordercolor="Black",
        borderwidth=2
    )
)

fig.show()

import pandas as pd
import plotly.graph_objects as go
from plotly.subplots import make_subplots

# Load IPC data
ipc = pd.read_csv('sp_bmv_ipc.csv')
columns_ipc = ['Price', 'Open', 'High', 'Low']
for col in columns_ipc:
    ipc[col] = ipc[col].str.replace(',', '').astype(float)
ipc['Vol.'] = ipc['Vol.'].apply(convert_volume)
ipc['Date'] = pd.to_datetime(ipc['Date'], format='%m/%d/%Y')

# Load sentiment data
sentiment = pd.read_csv('sentiment.csv')
sentiment['date'] = pd.to_datetime(sentiment['timestamp'])
sentiment.drop(columns=['timestamp', 'speech'], inplace=True)
sentiment_grouped = sentiment.groupby(pd.Grouper(key='date', freq='M')).mean().reset_index()

# Create subplots with shared x-axis
fig = make_subplots(rows=2, cols=1, shared_xaxes=True, subplot_titles=("IPC Time Series", "Sentiment Time Series"))

# Plot IPC data (initially monthly)
for col in columns_ipc:
    fig.add_trace(go.Scatter(x=ipc['Date'], y=ipc[col], mode='lines', name=f'IPC {col}'), row=1, col=1)

# Plot sentiment data (initially monthly)
for col in sentiment_grouped.columns[1:]:  # Exclude 'date' column
    fig.add_trace(go.Scatter(x=sentiment_grouped['date'], y=sentiment_grouped[col], mode='lines', name=col), row=2, col=1)

# Update layout with dropdown selector
fig.update_layout(
    title_text="IPC and Sentiment Time Series",
    xaxis=dict(title='Date', tickangle=45),
    yaxis=dict(title='IPC', tickformat=","),
    yaxis2=dict(title='Sentiment', tickformat=","),
    legend=dict(
        x=0,
        y=1,
        traceorder="normal",
        font=dict(
            family="sans-serif",
            size=12,
            color="black"
        ),
        bgcolor="LightSteelBlue",
        bordercolor="Black",
        borderwidth=2
    ),
    updatemenus=[
        dict(
            buttons=list([
                dict(
                    args=[{"visible": [True]*len(columns_ipc) + [True]*len(sentiment_grouped.columns[1:])}],
                    label="Monthly",
                    method="update"
                ),
                dict(
                    args=[{"visible": [True]*len(columns_ipc) + [False]*len(sentiment_grouped.columns[1:])}],
                    label="IPC Daily",
                    method="update"
                ),
                dict(
                    args=[{"visible": [False]*len(columns_ipc) + [True]*len(sentiment_grouped.columns[1:])}],
                    label="Sentiment Daily",
                    method="update"
                ),
                dict(
                    args=[{"visible": [False]*len(columns_ipc) + [False]*len(sentiment_grouped.columns[1:])}],
                    label="Hide All",
                    method="update"
                )
            ]),
            direction="down",
            pad={"r": 10, "t": 10},
            showactive=True,
            x=0.05,
            xanchor="left",
            y=1.15,
            yanchor="top"
        ),
    ]
)

fig.show()

sentiment

import pandas as pd
import plotly.graph_objects as go
from plotly.subplots import make_subplots

# Load IPC data
ipc = pd.read_csv('sp_bmv_ipc.csv')
columns_ipc = ['Price', 'Open', 'High', 'Low']
for col in columns_ipc:
    ipc[col] = ipc[col].str.replace(',', '').astype(float)
ipc['Vol.'] = ipc['Vol.'].apply(convert_volume)
ipc['Date'] = pd.to_datetime(ipc['Date'], format='%m/%d/%Y')

# Load sentiment data
sentiment = pd.read_csv('sentiment.csv')
sentiment['date'] = pd.to_datetime(sentiment['timestamp'])
sentiment.drop(columns=['timestamp', 'speech', 'NONE'], inplace=True)

# Initially, we use daily aggregation
sentiment_grouped = sentiment.copy()
ipc_grouped = ipc.copy()

# Create subplots with shared x-axis
fig = make_subplots(rows=2, cols=1, shared_xaxes=True, row_heights=[0.7, 0.3], vertical_spacing=0.1)

# Plot sentiment data (initially daily)
for col in sentiment_grouped.columns[1:]:  # Exclude 'date' column
    fig.add_trace(go.Scatter(x=sentiment_grouped['date'], y=sentiment_grouped[col], mode='lines', name=col, visible='legendonly'), row=1, col=1)

# Plot IPC data (initially daily)
for col in columns_ipc:
    fig.add_trace(go.Scatter(x=ipc_grouped['Date'], y=ipc_grouped[col], mode='lines', name=f'IPC {col}', visible='legendonly'), row=2, col=1)

# Function to update data based on aggregation selection
sentiment_grouped_monthly = sentiment.groupby(pd.Grouper(key='date', freq='M')).mean().reset_index()
ipc_grouped_monthly = ipc.groupby(pd.Grouper(key='Date', freq='M')).mean().reset_index()

sentiment_grouped_yearly = sentiment.groupby(pd.Grouper(key='date', freq='Y')).mean().reset_index()
sentiment_grouped_yearly['date'] = sentiment_grouped_yearly['date'].dt.strftime('%Y')
ipc_grouped_yearly = ipc.groupby(pd.Grouper(key='Date', freq='Y')).mean().reset_index()
ipc_grouped_yearly['Date'] = ipc_grouped_yearly['Date'].dt.strftime('%Y')


# Update layout with dropdown selector
fig.update_layout(
    xaxis=dict(title='Date', tickangle=45),
    yaxis=dict(title='Sentiment', tickformat=",", range=[0, 1]),  # Set the range for y-axis of sentiment plot
    yaxis2=dict(title='IPC', tickformat=","),
    updatemenus=[
        dict(
            buttons=list([
                dict(
                    args=[{"visible": [True]*len(sentiment.columns[1:]) + [True]*len(columns_ipc)},
                          {"title": "Sentiment and IPC Time Series"}],
                    label="Daily",
                    method="update"
                ),
                dict(
                    args=[{"visible": [True]*len(sentiment_grouped_monthly.columns[1:]) + [True]*len(columns_ipc)},
                          {"title": "Monthly Aggregated Sentiment and IPC Time Series"}],
                    label="Monthly",
                    method="update"
                ),
                dict(
                    args=[{"visible": [True]*len(sentiment_grouped_yearly.columns[1:]) + [True]*len(columns_ipc)},
                          {"title": "Yearly Aggregated Sentiment and IPC Time Series"}],
                    label="Yearly",
                    method="update"
                )
            ]),
            direction="down",
            pad={"r": 10, "t": 10},
            showactive=True,
            x=0.05,
            xanchor="left",
            y=1.05,
            yanchor="top"
        ),
    ]
)

fig.show()

sentiment_grouped_yearly = sentiment.groupby(pd.Grouper(key='date', freq='Y')).mean().reset_index()

sentiment_grouped_yearly

import pandas as pd
import plotly.graph_objects as go
from plotly.subplots import make_subplots

# Load IPC data
ipc = pd.read_csv('sp_bmv_ipc.csv')
columns_ipc = ['Price', 'Open', 'High', 'Low']
for col in columns_ipc:
    ipc[col] = ipc[col].str.replace(',', '').astype(float)
ipc['Vol.'] = ipc['Vol.'].apply(convert_volume)
ipc['Date'] = pd.to_datetime(ipc['Date'], format='%m/%d/%Y')

# Load sentiment data
sentiment = pd.read_csv('sentiment.csv')
sentiment['date'] = pd.to_datetime(sentiment['timestamp'])
sentiment.drop(columns=['timestamp', 'speech', 'NONE'], inplace=True)
sentiment_grouped_monthly = sentiment.groupby(pd.Grouper(key='date', freq='M')).mean().reset_index()

# Create subplots with shared x-axis
fig = make_subplots(rows=2, cols=1, shared_xaxes=True)

# Plot sentiment data (initially monthly)
for col in sentiment_grouped_monthly.columns[1:]:  # Exclude 'date' column
    visible = True if col == 'N-' else False  # Set 'N-' trace visible by default
    fig.add_trace(go.Scatter(x=sentiment_grouped_monthly['date'], y=sentiment_grouped_monthly[col], mode='lines', name=col, visible=visible), row=1, col=1)

# Plot IPC data (initially monthly)
for col in columns_ipc:
    fig.add_trace(go.Scatter(x=ipc['Date'], y=ipc[col], mode='lines', name=f'IPC {col}', visible='legendonly'), row=2, col=1)

# Function to update data based on aggregation selection
def update_data(aggregation):
    if aggregation == 'Monthly':
        sentiment_grouped = sentiment_grouped_monthly
        ipc_grouped = ipc.groupby(pd.Grouper(key='Date', freq='M')).mean().reset_index()
    elif aggregation == 'Daily':
        sentiment_grouped = sentiment
        ipc_grouped = ipc
    elif aggregation == 'Yearly':
        sentiment_grouped = sentiment.groupby(pd.Grouper(key='date', freq='Y')).mean().reset_index()
        ipc_grouped = ipc.groupby(pd.Grouper(key='Date', freq='Y')).mean().reset_index()

# Update layout with dropdown selector
fig.update_layout(
    xaxis=dict(title='Date', tickangle=45),
    yaxis=dict(title='Sentiment', tickformat=","),
    yaxis2=dict(title='IPC', tickformat=","),
    updatemenus=[
        dict(
            buttons=list([
                dict(
                    args=[{"visible": [True]*len(sentiment_grouped_monthly.columns[1:]) + [True]*len(columns_ipc)}],
                    label="Monthly",
                    method="update"
                ),
                dict(
                    args=[{"visible": [True]*len(sentiment.columns[1:]) + [True]*len(columns_ipc)}],
                    label="Daily",
                    method="update"
                ),
                dict(
                    args=[{"visible": [True]*len(sentiment_grouped_yearly.columns[1:]) + [True]*len(columns_ipc)}],
                    label="Yearly",
                    method="update"
                )
            ]),
            direction="down",
            pad={"r": 10, "t": 10},
            showactive=True,
            x=0.05,
            xanchor="left",
            y=1.05,
            yanchor="top"
        ),
    ]
)

fig.show()

sentiment

import pandas as pd
import plotly.graph_objects as go
from plotly.subplots import make_subplots

# Load IPC data
ipc = pd.read_csv('sp_bmv_ipc.csv')
columns_ipc = ['Price', 'Open', 'High', 'Low']
for col in columns_ipc:
    ipc[col] = ipc[col].str.replace(',', '').astype(float)
ipc['Vol.'] = ipc['Vol.'].apply(convert_volume)
ipc['Date'] = pd.to_datetime(ipc['Date'], format='%m/%d/%Y')

# Load sentiment data
sentiment = pd.read_csv('sentiment.csv')
sentiment['date'] = pd.to_datetime(sentiment['timestamp'])
sentiment.drop(columns=['timestamp', 'speech', 'NONE'], inplace=True)
sentiment_grouped_monthly = sentiment.groupby(pd.Grouper(key='date', freq='M')).mean().reset_index()

# Create subplots with shared x-axis
fig = make_subplots(rows=2, cols=1, shared_xaxes=True)

# Plot sentiment data (initially monthly)
for col in sentiment_grouped_monthly.columns[1:]:  # Exclude 'date' column
    visible = True if col == 'N-' else False  # Set 'N-' trace visible by default
    fig.add_trace(go.Scatter(x=sentiment_grouped_monthly['date'], y=sentiment_grouped_monthly[col], mode='lines', name=col, visible=visible), row=1, col=1)

# Plot IPC data (initially monthly)
for col in columns_ipc:
    fig.add_trace(go.Scatter(x=ipc['Date'], y=ipc[col], mode='lines', name=f'IPC {col}', visible='legendonly'), row=2, col=1)

# Function to update data based on aggregation selection
def update_data(aggregation):
    if aggregation == 'Monthly':
        sentiment_grouped = sentiment_grouped_monthly
        ipc_grouped = ipc.groupby(pd.Grouper(key='Date', freq='M')).mean().reset_index()
    elif aggregation == 'Daily':
        sentiment_grouped = sentiment
        ipc_grouped = ipc
    elif aggregation == 'Yearly':
        sentiment_grouped = sentiment.groupby(pd.Grouper(key='date', freq='Y')).mean().reset_index()
        ipc_grouped = ipc.groupby(pd.Grouper(key='Date', freq='Y')).mean().reset_index()
    else:
        raise ValueError("Invalid aggregation selected")

    return ipc_grouped, sentiment_grouped

# Update layout with dropdown selector
fig.update_layout(
    xaxis=dict(title='Date', tickangle=45),
    yaxis=dict(title='Sentiment', tickformat=","),
    yaxis2=dict(title='IPC', tickformat=","),
    updatemenus=[
        dict(
            buttons=list([
                dict(
                    args=[{"visible": [True]*len(sentiment_grouped_monthly.columns[1:]) + [True]*len(columns_ipc)}],
                    label="Monthly",
                    method="update"
                ),
                dict(
                    args=[{"visible": [True]*len(sentiment.columns[1:]) + [False]*len(columns_ipc)}],
                    label="Daily",
                    method="update"
                ),
                dict(
                    args=[{"visible": [False]*len(sentiment_grouped_monthly.columns[1:]) + [True]*len(columns_ipc)}],
                    label="Yearly",
                    method="update"
                )
            ]),
            direction="down",
            pad={"r": 10, "t": 10},
            showactive=True,
            x=0.05,
            xanchor="left",
            y=1.05,
            yanchor="top"
        ),
    ]
)

fig.show()

import pandas as pd
import plotly.graph_objects as go
from plotly.subplots import make_subplots

# Load IPC data
ipc = pd.read_csv('sp_bmv_ipc.csv')
columns_ipc = ['Price', 'Open', 'High', 'Low']
for col in columns_ipc:
    ipc[col] = ipc[col].str.replace(',', '').astype(float)
ipc['Vol.'] = ipc['Vol.'].apply(convert_volume)
ipc['Date'] = pd.to_datetime(ipc['Date'], format='%m/%d/%Y')

# Load sentiment data
sentiment = pd.read_csv('sentiment.csv')
sentiment['date'] = pd.to_datetime(sentiment['timestamp'])
sentiment.drop(columns=['timestamp', 'speech'], inplace=True)
sentiment_grouped_monthly = sentiment.groupby(pd.Grouper(key='date', freq='M')).mean().reset_index()

# Create subplots with shared x-axis
fig = make_subplots(rows=2, cols=1, shared_xaxes=True)

# Plot sentiment data (initially monthly)
for col in sentiment_grouped_monthly.columns[1:]:  # Exclude 'date' column
    fig.add_trace(go.Scatter(x=sentiment_grouped_monthly['date'], y=sentiment_grouped_monthly[col], mode='lines', name=col, visible='legendonly'), row=1, col=1)

# Plot IPC data (initially monthly)
for col in columns_ipc:
    fig.add_trace(go.Scatter(x=ipc['Date'], y=ipc[col], mode='lines', name=f'IPC {col}', visible='legendonly'), row=2, col=1)

# Function to update data based on aggregation selection
def update_data(aggregation, sentiment_indicators, ipc_indicators):
    if aggregation == 'Monthly':
        sentiment_grouped = sentiment_grouped_monthly
        ipc_grouped = ipc.groupby(pd.Grouper(key='Date', freq='M')).mean().reset_index()
    elif aggregation == 'Daily':
        sentiment_grouped = sentiment
        ipc_grouped = ipc
    elif aggregation == 'Yearly':
        sentiment_grouped = sentiment.groupby(pd.Grouper(key='date', freq='Y')).mean().reset_index()
        ipc_grouped = ipc.groupby(pd.Grouper(key='Date', freq='Y')).mean().reset_index()
    else:
        raise ValueError("Invalid aggregation selected")

    # Filter indicators
    sentiment_grouped = sentiment_grouped[['date'] + sentiment_indicators]
    ipc_grouped = ipc_grouped[['Date'] + ipc_indicators]

    return ipc_grouped, sentiment_grouped

# Update layout with dropdown selectors
fig.update_layout(
    xaxis=dict(title='Date', tickangle=45),
    yaxis=dict(title='Sentiment', tickformat=","),
    yaxis2=dict(title='IPC', tickformat=","),
    updatemenus=[
        dict(
            buttons=list([
                dict(
                    args=[{"visible": [True]*len(sentiment_grouped_monthly.columns[1:]) + [True]*len(columns_ipc)}],
                    label="Monthly",
                    method="update"
                ),
                dict(
                    args=[{"visible": [True]*len(sentiment.columns[1:]) + [False]*len(columns_ipc)}],
                    label="Daily",
                    method="update"
                ),
                dict(
                    args=[{"visible": [False]*len(sentiment_grouped_monthly.columns[1:]) + [True]*len(columns_ipc)}],
                    label="Yearly",
                    method="update"
                )
            ]),
            direction="down",
            pad={"r": 10, "t": 10},
            showactive=True,
            x=0.05,
            xanchor="left",
            y=1.05,
            yanchor="top"
        ),
        dict(
            buttons=list([
                dict(
                    args=[{"visible": [True]*len(sentiment_grouped_monthly.columns[1:]) + [False]*len(columns_ipc)}],
                    label="All Sentiment",
                    method="update"
                ),
                dict(
                    args=[{"visible": [False]*len(sentiment_grouped_monthly.columns[1:]) + [True]*len(columns_ipc)}],
                    label="All IPC",
                    method="update"
                )
            ]),
            direction="down",
            pad={"r": 10, "t": 10},
            showactive=True,
            x=0.15,
            xanchor="left",
            y=1.05,
            yanchor="top"
        ),
    ]
)

fig.show()

df = df.drop('Change %', axis=1)
columns = ['Price', 'Open', 'High', 'Low', 'Vol.']
for col in columns:
   # Plot daily time series
  time_series(df, col, freq='D')

  # Plot monthly time series
  time_series(df, col,  freq='M')

# Plot yearly time series
  time_series(df, col, freq='Y')

df['Price'].corr(df['Vol.'])

df['Price'].corr(df['High'])

vic24 = pd.read_excel('CNSP-Víctimas-2024_mar24.xlsx')
vic23 = pd.read_excel('CNSP-Víctimas-2023_mar24.xlsx')
vic22 = pd.read_excel('CNSP-Víctimas-2022_mar24.xlsx')
vic21 = pd.read_excel('CNSP-Víctimas-2021_mar24.xlsx')
vic20 = pd.read_excel('CNSP-Víctimas-2020_nov23.xlsx')
vic19 = pd.read_excel('CNSP-Víctimas-2019_nov23.xlsx')
vic18 = pd.read_excel('CNSP-Víctimas-2018_dic23.xlsx')

def preprocess_dataframe(df):
    df = df.drop(columns=['Unnamed: 0'])
    df.columns = df.iloc[6]
    df = df.iloc[7:]
    df.reset_index(drop=True, inplace=True)
    # Fix/review this!!
    df = df.iloc[1:]
    df = df.drop('Total', axis=1)

    return df

def preprocess_and_pivot(df, year):
    # Melt the DataFrame to convert it into a long format
    df_melted = df.melt(
        id_vars=['Clave', 'Tipo de delito, subtipo y modalidad'], var_name='Month', value_name='Value'
    )
    df_melted = df_melted.dropna(subset=['Month'])

    # Add a constant value for the 'Year' column (e.g., 2024)
    df_melted['Year'] = year  # Change this to the appropriate year
    df_melted['Day'] = '1'  # Change this to the appropriate day
    df_melted['Month'] = df_melted['Month'].str.strip()

    # Convert month names to numeric values
    month_to_num = {
        'Enero': '1', 'Febrero': '2', 'Marzo': '3', 'Abril': '4',
        'Mayo': '5', 'Junio': '6', 'Julio': '7', 'Agosto': '8',
        'Septiembre': '9', 'Octubre': '10', 'Noviembre': '11',
        'Diciembre': '12'
    }
    df_melted['Month'] = df_melted['Month'].map(month_to_num)

    # Combine 'Month', 'Day', and 'Year' into a single 'Date' column
    df_melted['Date'] = pd.to_datetime(df_melted['Year'].astype(str) + '-' + df_melted['Month'].astype(str) + '-' + df_melted['Day'].astype(str))

    # Pivot the DataFrame to reshape it into a time series format
    df_time_series = df_melted.pivot_table(index=['Date'], columns='Tipo de delito, subtipo y modalidad', values='Value')

    # Reset the index
    df_time_series.reset_index(inplace=True)

    return df_time_series

vic24 = preprocess_dataframe(vic24)
vic24 = preprocess_and_pivot(vic24, '2024')

vic23 = preprocess_dataframe(vic23)
vic23 = preprocess_and_pivot(vic23, '2023')

vic22 = preprocess_dataframe(vic22)
vic22 = preprocess_and_pivot(vic22, '2022')

vic21 = preprocess_dataframe(vic21)
vic21 = preprocess_and_pivot(vic21, '2021')

vic20 = preprocess_dataframe(vic20)
vic20 = preprocess_and_pivot(vic20, '2020')

vic19 = preprocess_dataframe(vic19)
vic19 = preprocess_and_pivot(vic19, '2019')

vic18 = preprocess_dataframe(vic18)
vic18 = preprocess_and_pivot(vic18, '2018')

frames = [vic24, vic23, vic22, vic21, vic20, vic19, vic18]
final_vict = pd.concat(frames, ignore_index=True)



final_vict.columns

final_vict

import pandas as pd
import matplotlib.pyplot as plt

# Assuming your dataframe is already loaded into a variable called df
df = final_vict
# Convert 'Date' column to datetime format if it's not already in datetime format
df['Date'] = pd.to_datetime(df['Date'])

# Set 'Date' column as the index of the dataframe
df.set_index('Date', inplace=True)

# Plot each variable as a time series
variables = df.columns
num_variables = len(variables)
num_cols = 2  # Number of columns in the subplot grid
num_rows = (num_variables + 1) // num_cols  # Number of rows in the subplot grid

fig, axes = plt.subplots(num_rows, num_cols, figsize=(15, 25))

for i, var in enumerate(variables):
    row = i // num_cols
    col = i % num_cols
    ax = axes[row, col] if num_rows > 1 else axes[col]
    ax.plot(df.index, df[var])
    ax.set_title(var)
    ax.set_xlabel('Date')
    ax.set_ylabel('Value')

# Adjust layout
plt.tight_layout()
plt.show()

# Set 'Date' column as the index of the dataframe
df= final_vict
df.set_index('Date', inplace=True)

# Plot each variable as a time series
variables = df.columns
num_variables = len(variables)
num_cols = 2  # Number of columns in the subplot grid
num_rows = (num_variables + 1) // num_cols  # Number of rows in the subplot grid

fig, axes = plt.subplots(num_rows, num_cols, figsize=(25, 10))

for i, var in enumerate(variables):
    row = i // num_cols
    col = i % num_cols
    ax = axes[row, col] if num_rows > 1 else axes[col]
    ax.plot(df.index, df[var])
    ax.set_title(var)
    ax.set_xlabel('Date')
    ax.set_ylabel('Value')

# Adjust layout
plt.tight_layout()
plt.show()

!gdown https://drive.google.com/uc?id=1pkIlUP1x2OUPhCbXxgBYlNc5zWNSMtra

import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.ticker as mtick
df=pd.read_csv('sentiment.csv')

df['timestamp'] = pd.to_datetime(df['timestamp'])
df.drop('speech', axis=1, inplace=True)
# Set 'Date' column as the index of the dataframe
df.set_index('timestamp', inplace=True)

# Group by date and calculate mean, max, min, and mode for each group
df = df.groupby('timestamp').agg(
    {'N-': ['mean', 'max', 'min'],'N': ['mean', 'max', 'min'],
                                          'NEU': ['mean', 'max', 'min'],
                                          'NONE': ['mean', 'max', 'min'],
                                          'P': ['mean', 'max', 'min'],
                                          'P+': ['mean', 'max', 'min']})
# Plot each variable as a time series
variables = df.columns
num_variables = len(variables)
num_cols = 2  # Number of columns in the subplot grid
num_rows = (num_variables + 1) // num_cols  # Number of rows in the subplot grid

fig, axes = plt.subplots(num_rows, num_cols, figsize=(15, 25))

for i, var in enumerate(variables):
    row = i // num_cols
    col = i % num_cols
    ax = axes[row, col] if num_rows > 1 else axes[col]
    ax.plot(df.index, df[var])
    ax.set_title(var)
    ax.set_xlabel('Date')
    ax.set_ylabel('Value')

# Adjust layout
plt.tight_layout()
plt.show()

def time_series____(df, indicator, date='Date'):
    """
    Plots a time series of Price against Date
    """
    # Plot
    plt.figure(figsize=(6, 6))
    plt.plot(df[date], df[indicator], marker='o', linestyle='-')
    plt.title('Time Series of Price')
    plt.xlabel('Date')
    plt.ylabel(indicator)
    plt.grid(False)
    plt.xticks(rotation=45)
    plt.tight_layout()
    plt.show()

df=df.reset_index()

df

for col in df.columns:
  time_series____(df, col, date='timestamp')

df



import pandas as pd

#!gdown https://drive.google.com/uc?id=1kFlGlyRvA3MmkDzrb6fTDiBs-hgnwy-9
!gdown https://drive.google.com/uc?id=1pkIlUP1x2OUPhCbXxgBYlNc5zWNSMtra

sentiment=pd.read_csv('sentiment.csv')
import plotly.express as px
import pandas as pd

# Assuming your data is stored in a DataFrame named df
df = sentiment.drop('speech', axis=1)
# Convert 'timestamp' column to datetime
df['timestamp'] = pd.to_datetime(df['timestamp'])

# Rename the 'timestamp' column to avoid conflict
df.rename(columns={'timestamp': 'date'}, inplace=True)
# Aggregate data by month
monthly_data = df.drop(columns=['date']).groupby(df_new['date'].dt.to_period('M')).mean().reset_index()

monthly_data['date'] = monthly_data['date'].astype(str)



# Aggregate data by year
yearly_data = df.drop(columns=['date']).groupby(df['date'].dt.year).mean().reset_index()

# Plot daily data
#fig1 = px.line(daily_data, x='date', y=['N-', 'N', 'NEU', 'NONE', 'P', 'P+'],
               #title='Daily Aggregated Sentiment Scores')
#fig1.show()

# Plot monthly data
fig2 = px.line(monthly_data, x='date', y=['N-', 'N', 'NEU', 'NONE', 'P', 'P+'],
               title='Monthly Aggregated Sentiment Scores')
fig2.show()

# Plot yearly data
fig3 = px.line(yearly_data, x='date', y=['N-', 'N', 'NEU', 'NONE', 'P', 'P+'],
               title='Yearly Aggregated Sentiment Scores')
fig3.show()

monthly_data
# Plot monthly data
fig2 = px.line(monthly_data, x='date', y=['N-', 'N', 'NEU', 'NONE', 'P', 'P+'],
               title='Monthly Aggregated Sentiment Scores')
fig2.show()

# Aggregate data by month
monthly_data = df.drop(columns=['date']).groupby(df_new['date'].dt.to_period('M')).mean().reset_index()

monthly_data['date'] = monthly_data['date'].astype(str)



# Aggregate data by year
yearly_data = df.drop(columns=['date']).groupby(df['date'].dt.year).mean().reset_index()

# Plot daily data
#fig1 = px.line(daily_data, x='date', y=['N-', 'N', 'NEU', 'NONE', 'P', 'P+'],
               #title='Daily Aggregated Sentiment Scores')
#fig1.show()

# Plot monthly data
fig2 = px.line(monthly_data, x='date', y=['N-', 'N', 'NEU', 'NONE', 'P', 'P+'],
               title='Monthly Aggregated Sentiment Scores')
fig2.show()

# Plot yearly data
fig3 = px.line(yearly_data, x='date', y=['N-', 'N', 'NEU', 'NONE', 'P', 'P+'],
               title='Yearly Aggregated Sentiment Scores')
fig3.show()

df.reset_index(drop=True, inplace=True)
#ipc.reset_index(drop=True, inplace=True)
ipc.reset_index(inplace=True)


# Perform the merge operation
merged_df = pd.merge(df, ipc, left_on='timestamp', right_on='Date', how='inner')

# Drop the 'Date' column if you don't need it

# Display the merged DataFrame
print(merged_df)

list(df.columns)[18]

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Assuming you have a DataFrame named df with 'timestamp' and 'value' columns
# You can load your data or create a sample DataFrame for demonstration
# df = pd.read_csv('your_data.csv')

# Smooth the trend using a rolling window (e.g., 7 days)
df['smoothed_value'] = df[list(df.columns)[18]].rolling(window=7, min_periods=1).mean()

# Plot the trend
plt.figure(figsize=(10, 6))
sns.lineplot(x='timestamp', y=list(df.columns)[18], data=df, label='Original Trend', alpha=0.5)
sns.lineplot(x='timestamp', y='smoothed_value', data=df, label='Smoothed Trend')
plt.title('Trend Visualization with Smoothed Line')
plt.xlabel('Date')
plt.ylabel('Value')
plt.legend()
plt.xticks(rotation=45)  # Rotate x-axis labels for better readability
plt.tight_layout()
plt.show()

